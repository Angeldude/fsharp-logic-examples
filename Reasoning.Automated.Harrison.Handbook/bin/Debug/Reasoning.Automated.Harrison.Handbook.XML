<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Reasoning.Automated.Harrison.Handbook</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.bdd">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.combining.langpartition``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},``0}},Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}})">
<summary>
 Partition formulas among a list of languages.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.combining.belongs``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},``0,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol})">
<summary>
 Whether a formula belongs to a language.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.combining.homogenize``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},``0}},Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}})">
<summary>
 Overall homogenization.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.combining.homo``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},``0}},Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},Microsoft.FSharp.Core.FSharpFunc`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},``1}}})">
<summary>
 Fully homogenize a list of literals.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.combining.homol``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},``0}},Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},``1}}},FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}})">
<summary>
 Homogenize a literal.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.combining.homot``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.String,System.Int32},System.Boolean},``0,``1,Reasoning.Automated.Harrison.Handbook.folMod.term,Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.folMod.term,Microsoft.FSharp.Core.FSharpFunc`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},``2}}},FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}})">
<summary>
 Homogenize a term.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.combining">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.completion">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.complex">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.cong">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.cooper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.decidable">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.defcnf">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.dp">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.eqelim">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.equal">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.folMod">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.folderived">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.formulas">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.geom">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.grobner_trivial(Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}})">
<summary>
 Universal complex number decision procedure based on Grobner bases.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.rabinowitsch``1(Microsoft.FSharp.Collections.FSharpList{``0},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}})">
<summary>
 Use the Rabinowitsch trick to eliminate inequations. 
 That is, replace p =/= 0 by exists v. 1 - v * p = 0.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.groebner(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}}})">
<summary>
 Overall function.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.grobner(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}}}})">
<summary>
 Grobner basis algorithm.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.spoly(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}})">
<summary>
 Compute S-polynomial of two polynomials.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.reduce(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}})">
<summary>
 Reduction of a polynomial (always picking largest monomial possible).
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.reduceb(FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}}})">
<summary>
 Try this for all polynomials in a basis.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.grobner.reduce1(FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{FSharpx.Compatibility.OCaml.NumModule.Num,Microsoft.FSharp.Collections.FSharpList{System.Int32}}})">
<summary>
 Reduce monomial cm by polynomial pol, returning replacement for cm.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.grobner">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.herbrand">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.interpolation.toptermt(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.Int32}},Reasoning.Automated.Harrison.Handbook.folMod.term)">
<summary>
 Pick the topmost terms starting with one of the given function symbols.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.interpolation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.intro">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.lcf.ProverOperators">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.lcf">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.lcffol">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.lcfprop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.lib.butlastImpl``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{``0},``1})">
<summary>
 Private, recursive implementation of &apos;butlast&apos; which
 improves performance by using continuation-passing-style.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.lib.op_GreaterGreaterBarGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0},``2)">
<summary>
 Composes two functions, then applies a value to the resulting function.
</summary>
</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.lib">
<summary>
 Misc library functions to set up a nice environment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.meson">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.misc.divides(System.Int32,System.Int32)">
 <summary>Determines if one number is evenly divisible by another number,
 based on the semantics of the OCaml mod (%) operator.</summary>
 <remarks>The standard mod (%) operator in .NET (and in F#) throws a DivideByZeroException
 when 'y' is zero (0); however, the operation x % 0 simply returns zero (0) in OCaml, so
 that is the behavior preserved by this method.</remarks>
</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.misc">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.order">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.paramodulation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.prolog">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.prop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.propexamples">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.qelim">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.casesplit(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.folMod.term},Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.folMod.term},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign}},Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.complex.sign}})">
<summary>
 Main recursive evaluation of sign matrices.
</summary>
</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.split_sign(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.complex.sign}},Reasoning.Automated.Harrison.Handbook.folMod.term,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.complex.sign}},Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}})">
<summary>
 Case splitting for positive/negative (assumed nonzero).
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.pdivide_pos(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.complex.sign}},Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.folMod.term)">
<summary>
 Pseudo-division making sure the remainder has the same sign.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.dedmatrix``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign}},``0},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign}})">
<summary>
 Deduce matrix for p,p1,...,pn from matrix for p&apos;,p1,...,pn,q0,...,qn
 where qi = rem(p,pi) with p0 = p&apos;.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.inferisign(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign}})">
<summary>
 Infer sign on intervals (use with infinities at end) and split if needed
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.condense(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign}})">
<summary>
 Condense subdivision by removing points with no relevant zeros.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.real.inferpsign(Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign},Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.complex.sign})">
<summary>
 Infer sign of p(x) at points from corresponding qi(x) with pi(x) = 0.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.real">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.resolution">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.rewrite">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.skolem">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.skolems">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.stal">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.tableaux">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.disj_elim_tac``1(System.String,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.tactics.goals,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}}}},``0,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Elimination tactic for disjunction.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.ante_disj(Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol})">
<summary>
 If |- p ==&gt; r and |- q ==&gt; r then |- p \/ q ==&gt; r
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.exists_elim_tac``1(System.String,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.tactics.goals,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}}}},``0,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Elimination tactic for existential quantification.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.lemma_tac``1(System.String,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.tactics.goals,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}}}},``0,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 A &quot;lemma&quot; tactic.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.auto_tac``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.tactics.goals,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}}}},``0,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Hence an automated terminal tactic.
</summary>
</member>
<member name="">

</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.at``4(``0,``1,``2)">
<summary>
 Trivial justification, producing no hypotheses.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.proof(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.tactics.goals,Reasoning.Automated.Harrison.Handbook.tactics.goals}},Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Nested subproof.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.justify``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Microsoft.FSharp.Core.FSharpFunc`2{Reasoning.Automated.Harrison.Handbook.tactics.goals,Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}}}},``0,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol},Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Main automatic justification step.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.by``1(Microsoft.FSharp.Collections.FSharpList{System.String},``0,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Produce canonical theorem from list of theorems or assumption labels.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.assumps``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}})">
<summary>
 Turn assumptions p1,...,pn into theorems |- p1 /\ ... /\ pn ==&gt; pi
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.using``1(Microsoft.FSharp.Collections.FSharpList{Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}},``0,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Import &quot;external&quot; theorem.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.firstassum``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol}}})">
<summary>
 Get the first assumption (quicker than head of assumps result).
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.assumptate(Reasoning.Automated.Harrison.Handbook.tactics.goals,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol})">
<summary>
 Append contextual hypothesis to unconditional theorem.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.imp_intro_tac(System.String,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Implication introduction tactic.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.exists_intro_tac(Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Existential introduction.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.right_exists(System.String,Reasoning.Automated.Harrison.Handbook.folMod.term,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol})">
<summary>
 Another inference rule: |- P[t] ==&gt; exists x. P[x]
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.forall_intro_tac(System.String,Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Universal introduction.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.gen_right_alpha(System.String,System.String,Reasoning.Automated.Harrison.Handbook.formulas.formula{Reasoning.Automated.Harrison.Handbook.folMod.fol})">
<summary>
 Version of gen_right with a bound variable change.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.jmodify``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Collections.FSharpList{``0},``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Handy idiom for tactic that does not split subgoals.
</summary>
</member>
<member name="M:Reasoning.Automated.Harrison.Handbook.tactics.conj_intro_tac(Reasoning.Automated.Harrison.Handbook.tactics.goals)">
<summary>
 Conjunction introduction tactic.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.tactics">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Reasoning.Automated.Harrison.Handbook.unif">

</member>
</members>
</doc>
